{"ts":1354997460190,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\r\n * General-purpose utilities\r\n */\r\n\r\ndefine(\r\n[],\r\nfunction () {\r\n    var utils = {};\r\n    \r\n    /**\r\n     * Determine the radians of a given angle\r\n     * \r\n     * @param {Number} angle in degrees\r\n     * @return {Number} angle in radians\r\n     */\r\n     \r\n    utils.radians = function (angle) {\r\n        return angle * (Math.PI / 180); \r\n    };\r\n    \r\n    /**\r\n     * Determine the degrees of a given angle\r\n     * \r\n     * @param {Number} angle in radians\r\n     * @return {Number} angle in degrees\r\n     */\r\n    \r\n    utils.degrees = function (angle) {\r\n        return angle * (180 / Math.PI);  \r\n    };\r\n    \r\n    /**\r\n     * Determine the length of the hypotenuse for the given sides\r\n     * \r\n     * @param {Number} x Length of first side\r\n     * @param {Number} y Length of second side\r\n     * @return {Number} length of hypotenuse\r\n     */\r\n    \r\n    utils.hypotenuse = function (x, y) {\r\n        return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));  \r\n    };\r\n    \r\n    /**\r\n     * Round to specified number of decimal places\r\n     * \r\n     * @param {Number} number Number to round\r\n     * @param {Integer} dec Decimal places to round to\r\n     * @return {Number} rounded number\r\n     */\r\n    \r\n    utils.roundToDec = function (number, dec) {\r\n        var multiplier = Math.pow(10, dec);\r\n        return Math.round(number * multiplier) / multiplier;\r\n    };\r\n    \r\n    /**\r\n     * Round to specified precision (e.g 0.00001)\r\n     * \r\n     * @param {Number} number Number to round\r\n     * @param {Integer} precision Precision to round to (e.g. 0.0001)\r\n     * @return {Number} rounded number\r\n     */\r\n    \r\n    utils.roundToPrecision = function (number, precision) {\r\n        var dec = Math.round(utils.log10(1 / (precision || 1)));\r\n        return utils.roundToDec(number, dec);\r\n    };\r\n    \r\n    /**\r\n     * Find the base-10 log of the given number\r\n     * \r\n     * @param {Number} number\r\n     * @return {Number} log base-10\r\n     */\r\n    \r\n    utils.log10 = function (number) {\r\n        return Math.log(number) / Math.LN10;  \r\n    };\r\n    \r\n    /**\r\n     * Find the distance between two bodies\r\n     * \r\n     * @param {Body} start\r\n     * @param {Body} destination\r\n     * @return {Number} distance\r\n     */\r\n    \r\n    utils.distance = function (start, finish) {\r\n        return utils.hypotenuse(start.x - finish.x, start.y - finish.y);\r\n    };\r\n    \r\n    /**\r\n     * Find the angle between two bodies\r\n     * (wrt start body)\r\n     * \r\n     * @param {Body} start\r\n     * @param {Body} destination\r\n     * @return {Number} angle (in degrees)\r\n     */\r\n    \r\n    utils.angle = function (start, finish) {\r\n        return utils.degrees(Math.atan2(finish.y-start.y, finish.x-start.x));\r\n    };\r\n    \r\n    // Lodash methods\r\n    // [Lo-Dash](http://lodash.com/)\r\n    \r\n    /**\r\n     * Checks if `value` is a number\r\n     *\r\n     * @param {Mixed} value The value to check\r\n     * @returns {Boolean} Returns `true` if the `value` is a number, else `false`\r\n     * @source [Lo-Dash](http://lodash.com/)\r\n     */\r\n    utils.isNumber = function (value) {\r\n        return typeof value == 'number' || toString.call(value) == '[object Number]';\r\n    }\r\n    \r\n    /**\r\n     * Checks if `value` is a function.\r\n     *\r\n     * @param {Mixed} value The value to check\r\n     * @returns {Boolean} Returns `true` if the `value` is a function, else `false`\r\n     * @source [Lo-Dash](http://lodash.com/)\r\n     */\r\n     \r\n    utils.isFunction = function (value) {\r\n        return typeof value == 'function';\r\n    };\r\n    // fallback for older versions of Chrome and Safari\r\n    if (utils.isFunction(/x/)) {\r\n        utils.isFunction = function(value) {\r\n          return toString.call(value) == '[object Function]';\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Checks if the `callback` returns a truthy value for **any** element of a\r\n     * `collection`. The function returns as soon as it finds passing value, and\r\n     * does not iterate over the entire `collection`. The `callback` is \r\n     * invoked with three arguments; (value, index|key, collection).\r\n     *\r\n     * @param {Array} collection The collection to iterate over.\r\n     * @param {Function} callback The function called per iteration.\r\n     * @returns {Boolean} Returns `true` if any element passes the callback check,\r\n     *  else `false`\r\n     * @source [Lo-Dash](http://lodash.com/)\r\n     */\r\n     \r\n    utils.any = function (collection, callback) {\r\n        var result;\r\n    \r\n        var index = -1,\r\n            length = collection.length;\r\n    \r\n        while (++index < length) {\r\n            if ((result = callback(collection[index], index, collection))) {\r\n                break;\r\n            }\r\n        }\r\n        return !!result;\r\n    }\r\n    \r\n    return utils;\r\n});"]],"start1":0,"start2":0,"length1":0,"length2":4737}]],"length":4737}
{"contributors":[],"silentsave":false,"ts":1356818642827,"patch":[[{"diffs":[[0,"   }\r\n    \r\n"],[1,"    utils.relativePoint = function (initialPoint, angle, distance) {\r\n        return { \r\n            x: initialPoint.x + distance * Math.cos(utils.radians(angle)), \r\n            y: initialPoint.y + distance * Math.sin(utils.radians(angle))\r\n        };  \r\n    };\r\n    \r\n"],[0,"    return u"]],"start1":4703,"start2":4703,"length1":24,"length2":293}]],"length":5006,"saved":false}
{"ts":1356818814053,"patch":[[{"diffs":[[0,";\r\n    }\r\n    \r\n"],[1,"    /**\r\n     * Find point relative to initial point that is set distance and angle away\r\n     * \r\n     * @param {point} initialPoint x and y coordinates\r\n     * @param {Number} angle should be in degrees\r\n     * @param {Number} distance\r\n     */\r\n"],[0,"    utils.relati"]],"start1":4699,"start2":4699,"length1":32,"length2":280}]],"length":5254,"saved":false}
{"ts":1356820347644,"patch":[[{"diffs":[[0,"istance) {\r\n"],[1,"        console.log('Relative: ', initialPoint, angle, distance);\r\n"],[0,"        retu"]],"start1":5021,"start2":5021,"length1":24,"length2":91}]],"length":5321,"saved":false}
{"ts":1356820460259,"patch":[[{"diffs":[[0," {\r\n"],[-1,"        console.log('Relative: ', initialPoint, angle, distance);\r\n"],[0,"    "]],"start1":5029,"start2":5029,"length1":75,"length2":8}]],"length":5254,"saved":false}
{"ts":1356820862841,"patch":[[{"diffs":[[0,"tils = {"],[1,"},\r\n        zeroPoint = { x: 0, y: 0 "],[0,"};\r\n    "]],"start1":80,"start2":80,"length1":16,"length2":53},{"diffs":[[0,"istance) {\r\n"],[1,"        if (initialPoint == undefined) { initialPoint = zeroPoint; }\r\n"],[0,"        retu"]],"start1":5058,"start2":5058,"length1":24,"length2":94}]],"length":5361,"saved":false}
