{"ts":1354997446031,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\r\n * Body with mass, position, velocity, acceleration, and forces\r\n */\r\n\r\ndefine(\r\n['src/Vector', 'src/utils'],\r\nfunction (Vector, utils) {\r\n    \r\n    /**\r\n     * @class Body\r\n     * @param {Object} [options]\r\n     *     Any options to set inline (mass, x, y, v, a)\r\n     */\r\n    \r\n    var Body = function (options) {\r\n        // Set the default mass, position, velocity, and acceleration\r\n        this.mass = (options && options.mass) || 0;\r\n        this.x = (options && options.x) || 0;\r\n        this.y = (options && options.y) || 0;\r\n        this.v = (options && options.v) || new Vector();\r\n        this.a = (options && options.a) || new Vector();\r\n        \r\n        // Initialize forces and lifetime\r\n        this.forces = [];\r\n        this.lifetime = 0;\r\n        \r\n        return this;\r\n    };\r\n    \r\n    /**\r\n     * Global options for body\r\n     * @static\r\n     */\r\n    Body.options = {\r\n        // Default timestep (in ms)\r\n        timestep: 8,\r\n        \r\n        // Set maximum advance time to avoid infinite loops\r\n        maxAdvanceTime: 30000\r\n    };\r\n\r\n    /**\r\n     * Advance the body through time until the defined limit is reached,\r\n     * updating the body properties along the way\r\n     * \r\n     * Ex:\r\n     * \r\n     * // Advance the body 2 seconds into the future\r\n     * body.advance(2000);\r\n     * \r\n     * // Advance the body until x = 10, using 10 ms timesteps\r\n     * body.advance({ x: 10 }, 10);\r\n     * \r\n     * // Advance the body until the fn returns true\r\n     * body.advance(function () { ... return true; });\r\n     * @param {Number|Object|function} limit at which to stop advance (in ms)\r\n     * @param {Number} [timestep] Optional timestep in ms\r\n     *     (Use Body.options.timestep by default)\r\n     * @chainable\r\n     */\r\n\r\n    Body.prototype.advance = function (limit, timestep) {\r\n        var body = this,\r\n            elapsed = 0,\r\n            stopAdvance;\r\n        \r\n        // Set timestep (if undefined)\r\n        if (timestep === undefined) {\r\n            // If forces / a is variable or limit isn't a set time, use default, \r\n            // otherwise set at limit\r\n            if (body.isVariable() && utils.isNumber(limit)) {\r\n                // If the limit is set at a defined time, divide the timestep so that it\r\n                // hits close to limit\r\n                timestep = limit / Math.ceil(limit / Body.options.timestep);\r\n            } else {\r\n                timestep = utils.isNumber(limit) ? limit : Body.options.timestep;   \r\n            } \r\n        }\r\n        \r\n        if (timestep > 0) {\r\n            // Create stop advance callback\r\n            stopAdvance = createStopAdvanceCallback(limit);\r\n            \r\n            while(!stopAdvance(body, elapsed) && elapsed < Body.options.maxAdvanceTime) {\r\n                // Update elapsed time\r\n                elapsed += timestep; \r\n                \r\n                // Move object\r\n                body.move(timestep);           \r\n            }\r\n        }\r\n        \r\n        return body;\r\n    };\r\n    \r\n    /**\r\n     * Move the object by applying physics for the specified timestep\r\n     * \r\n     * @param {Number} timestep\r\n     * @chainable\r\n     */\r\n    Body.prototype.move = function (timestep) {\r\n        var body = this;\r\n        var vX = body.v.x();\r\n        var vY = body.v.y();\r\n        var netForce = body.netForce();\r\n        \r\n        // Update lifetime and convert timestep from ms to s\r\n        body.lifetime += timestep;\r\n        timestep = timestep / 1000;\r\n        \r\n        if (timestep > 0) {\r\n            // Apply physics\r\n            // 1. Update position based on velocity\r\n            body.x = body.x + (vX * timestep); // m = m + m/s * s (woohoo)\r\n            body.y = body.y + (vY * timestep);\r\n            \r\n            // 2. Set acceleration based on force (only if mass > 0)\r\n            body.a.x(body.mass > 0 ? netForce.x() / body.mass : 0);\r\n            body.a.y(body.mass > 0 ? netForce.y() / body.mass : 0);\r\n            \r\n            // 3. Update velocity based on acceleration\r\n            body.v.x(body.v.x() + (body.a.x() * timestep)); // m/s = m/s + m/s^2 * s (good)\r\n            body.v.y(body.v.y() + (body.a.y() * timestep));\r\n        }\r\n        \r\n        return body;\r\n    };\r\n    \r\n    /**\r\n     * Check if body has any variable forces or acceleration\r\n     * \r\n     * @return {Boolean}\r\n     * @prototype\r\n     */\r\n     \r\n    Body.prototype.isVariable = function () {\r\n        // Check if forces contains a function\r\n        return !!utils.any(this.forces, utils.isFunction);\r\n    };\r\n    \r\n    /**\r\n     * Calculate the net force currently acting on the body\r\n     * \r\n     * @return {Vector}\r\n     * @prototype\r\n     */\r\n    \r\n    Body.prototype.netForce = function () {\r\n        var body = this,\r\n            netForceX = 0,\r\n            netForceY = 0,\r\n            forceValue;\r\n        \r\n        for (var i = 0, max = body.forces.length; i < max; i += 1) {\r\n            // If force is function evaluate to get vector\r\n            forceValue = utils.isFunction(body.forces[i]) \r\n                ? body.forces[i]() \r\n                : body.forces[i];\r\n            \r\n            netForceX += forceValue.x();\r\n            netForceY += forceValue.y();\r\n        }\r\n        \r\n        // Set the x and y components of the net force\r\n        return new Vector().x(netForceX).y(netForceY);\r\n    };\r\n    \r\n    // Create stop advance callback based on the specified limit\r\n    var createStopAdvanceCallback = function (limit) {\r\n        // Advance requires a callback function that it checks on each step \r\n        // in order to determine whether to stop the advance\r\n        //\r\n        // The callback is a latch function that returns a `Boolean`\r\n        // and is `true` when it is time to stop\r\n        // \r\n        // limit: {Number} create function to check limit\r\n        // (Future) limit: {Object (State)| function}\r\n        //\r\n        // Callback form:\r\n        // @param {Object} body Instance of body\r\n        // @param {Number} elapsed Time that has elapsed during advance\r\n        // @return {Boolean} true = stop advance, false = continue\r\n        \r\n        // limit by elapsed time for stopAdvance callback\r\n        return function (body, elapsed) {\r\n            return elapsed >= limit;       \r\n        }\r\n    };\r\n\r\n    return Body;\r\n});\r\n"]],"start1":0,"start2":0,"length1":0,"length2":6306}]],"length":6306}
{"contributors":["tim.hall.engr@gmail.com"],"silentsave":false,"ts":1354997451525,"patch":[[{"diffs":[[0,"ine(\r\n['"],[-1,"src"],[1,"freebody"],[0,"/Vector'"]],"start1":79,"start2":79,"length1":19,"length2":24},{"diffs":[[0,"', '"],[-1,"src"],[1,"freebody"],[0,"/uti"]],"start1":102,"start2":102,"length1":11,"length2":16}]],"length":6316,"saved":false}
